// Code generated by MockGen. DO NOT EDIT.
// Source: internal/scheduler/scheduler.go

// Package scheduler is a generated GoMock package.
package scheduler

import (
	"context"
	reflect "reflect"

	"github.com/stretchr/testify/mock"

	gomock "github.com/golang/mock/gomock"
)

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockScheduler) Add(ctx context.Context, task *Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockSchedulerMockRecorder) Add(ctx, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockScheduler)(nil).Add), ctx, task)
}

// GetStatus mocks base method.
func (m *MockScheduler) GetStatus() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStatus")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetStatus indicates an expected call of GetStatus.
func (mr *MockSchedulerMockRecorder) GetStatus() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStatus", reflect.TypeOf((*MockScheduler)(nil).GetStatus))
}

// GetTask mocks base method.
func (m *MockScheduler) GetTask(taskID string) (*Task, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTask", taskID)
	ret0, _ := ret[0].(*Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTask indicates an expected call of GetTask.
func (mr *MockSchedulerMockRecorder) GetTask(taskID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTask", reflect.TypeOf((*MockScheduler)(nil).GetTask), taskID)
}

// ListTasks mocks base method.
func (m *MockScheduler) ListTasks() []*Task {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListTasks")
	ret0, _ := ret[0].([]*Task)
	return ret0
}

// ListTasks indicates an expected call of ListTasks.
func (mr *MockSchedulerMockRecorder) ListTasks() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTasks", reflect.TypeOf((*MockScheduler)(nil).ListTasks))
}

// Remove mocks base method.
func (m *MockScheduler) Remove(ctx context.Context, taskID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx, taskID)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockSchedulerMockRecorder) Remove(ctx, taskID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockScheduler)(nil).Remove), ctx, taskID)
}

// Start mocks base method.
func (m *MockScheduler) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockSchedulerMockRecorder) Start(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockScheduler)(nil).Start), ctx)
}

// Stop mocks base method.
func (m *MockScheduler) Stop(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockSchedulerMockRecorder) Stop(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockScheduler)(nil).Stop), ctx)
}

// UpdateTask mocks base method.
func (m *MockScheduler) UpdateTask(ctx context.Context, task *Task) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateTask", ctx, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateTask indicates an expected call of UpdateTask.
func (mr *MockSchedulerMockRecorder) UpdateTask(ctx, task interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTask", reflect.TypeOf((*MockScheduler)(nil).UpdateTask), ctx, task)
}

// MockExecutor is a mock of Executor interface.
type MockExecutor struct {
	mock.Mock
}

// Execute mocks base method.
func (m *MockExecutor) Execute(ctx context.Context, task *Task) (*Result, error) {
	args := m.Called(ctx, task)
	return args.Get(0).(*Result), args.Error(1)
}

// ExecuteBatch mocks base method.
func (m *MockExecutor) ExecuteBatch(ctx context.Context, tasks []*Task) ([]*Result, error) {
	args := m.Called(ctx, tasks)
	return args.Get(0).([]*Result), args.Error(1)
}

// GetConcurrencyLimit mocks base method.
func (m *MockExecutor) GetConcurrencyLimit() int {
	args := m.Called()
	return args.Int(0)
}

// SetConcurrencyLimit mocks base method.
func (m *MockExecutor) SetConcurrencyLimit(limit int) error {
	args := m.Called(limit)
	return args.Error(0)
}

// MockMonitor is a mock of Monitor interface.
type MockMonitor struct {
	mock.Mock
}

// GetMetrics mocks base method.
func (m *MockMonitor) GetMetrics() map[string]interface{} {
	args := m.Called()
	return args.Get(0).(map[string]interface{})
}

// GetTaskMetrics mocks base method.
func (m *MockMonitor) GetTaskMetrics(taskID string) map[string]interface{} {
	args := m.Called(taskID)
	return args.Get(0).(map[string]interface{})
}

// Record mocks base method.
func (m *MockMonitor) Record(ctx context.Context, result *Result) error {
	args := m.Called(ctx, result)
	return args.Error(0)
}
